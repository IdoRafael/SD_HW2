תהליך הפירסור בהתחלה:
	*עובר על הכל. מתייחס רק למוצרים (מתעלם מהשאר-הזמנה,שינוי,ביטול) כל מוצר מכניס למפה הממוינת לקסיקוגרפית לפי ID של המוצר.
		
	* עובר על הכל. מתעלם ממוצרים ומתייחס רק לשאר:
		*אם הזמנה
			*אם לא קיים מוצר כמו בהזמנה, מתעלם.
			*אחרת (קיים מוצר כמו בהזמנה), מאפס את היסטורית השינוים של המוצר, והאם בוטל או לא, ודורס עם הזמנה חדשה.
			
		*אם שינוי:
			*אם ההזמנה לא קיימת: מתעלם.
			*אחרת (ההזמנה קיימת): מוסיף שינוי להזמנה. הופך ל-"לא מבוטלת" (אם היא כבר לא מבוטלת אז זה לא עושה שום שינוי גם ככה).
		
		*אם ביטול:
			*אם ההזמנה לא קיימת: מתעלם.
			*אחרת (ההזמנה קיימת): הופך למבוטלת (אם היא כבר מבוטלת אז זה לא עושה שום שינוי גם ככה).
			
לאחר הפירסור (שקורה באפליקציה ב-initializer) אנחנו יכולים כבר ליצור את 4 ה-StringStorage הראשונים.
את ה-2 הנותרים צריך לוודא שאנחנו סוכמים את כל הכמויות למוצר מסוים לכל משתמש (כי כל משתמש יכול לקנות את אותו המוצר בכמה הזמנות שונות)

			
מבנה ה-DB:
	*משתמשים+הזמנות (משתמשID, הזמנהID, כמותעדכנית, בוטל\לא, שונה\לא)
	*הזמנות+מוצרים(הזמנהID, מוצרID, כמותעדכנית, בוטל\לא)
	*הזמנות+היסטוריה (הזמנהID, מספרשינוי, כמות) (כולל הגדרה ראשונית)(לשים לב ש-מספר שינוי אם הוא מספר אז מומר למחרוזת ממוינת לקסיקוגרפית, וזה כבר דופק. לחשוב על פתרון!!!)
	*מוצרים+הזמנות (מוצרID, הזמנהID, כמות, בוטל\לא)
	*משתמשים+מוצרים(משתמשID, מוצרID, כמות, מחיר) (ללא הזמנות מבוטלות) (הכמות היא סה"כ לכל ההזמנות הלא מבוטלות של אותו המשתמש למוצר)
	*מוצרים+משתמשים (מוצרID, משתמשID, כמות )(ללא הזמנות מבוטלות) (הכמות היא סה"כ לכל ההזמנות הלא מבוטלות של אותו המשתמש למוצר)
	
מימוש האפליקציה:
	isValidOrderId - מחפש ב-הזמנות+מוצרים
	isCanceledOrder - מחפש ב-הזמנות+מוצרים
	isModifiedOrder - מחפש ב-הזמנות+היסטוריה לפי הזמנהID, ומספר שינוי=1
	getNumberOfProductOrdered - מחפש ב-הזמנות+מוצרים ושולף כמות עדכנית, כופל ב-1- אם בוטל.
	getHistoryOfOrder - מחפש בהזמנות+היסטוריה -> מחזיר את כל הרשומות של ORDER_ID.
	getOrderIdsForUser - מחפש ב-משתמשים+הזמנות -> מחזיר את כל הרשומות של USER_ID.
	getTotalAmountSpentByUser - מחפש ב-משתמשים+מוצרים -> מחזיר את כל הרשומות של USER_ID, ויכול לחשב מחיר*כמות
	getUsersThatPurchased - מחפש ב-מוצרים+משתמשים -> מחזיר את כל הרשומות של productID.
	getOrderIdsThatPurchased - מחפש ב-מוצרים+הזמנות -> מחזיר את כל הרשומות של productId.
	getTotalNumberOfItemsPurchased - מחפש ב-מוצרים+משתמשים-> מחזיר את כל הרשומות של productId.
	getAverageNumberOfItemsPurchased - מחפש ב-מוצרים+הזמנות-> מחזיר את כל הרשומות של productId. מתעלם מהזמנות מבוטלות. לבדוק מה קורה אם כל ההזמנות מבוטלות (ריק או 0)
	getCancelRatioForUser - מחפש ב-משתמשים+הזמנות -> מחזיר את כל הרשומות של userId, וסופר כמה בוטלו מתוך סה"כ.
	getModifyRatioForUser - מחפש ב-משתמשים+הזמנות -> מחזיר את כל הרשומות של userId. סופר כמה שונו מתוך סה"כ.
	getAllItemsPurchased - מחפש ב-משתמשים+מוצרים -> מחזיר את כל הרשומות של userId. לכל מוצר את הכמות סה"כ.
	getItemsPurchasedByUsers - מחפש ב-מוצרים+משתמשים -> מחזיר את כל הרשומות של productId. לכל מוצר הכמות סה"כ.

הספריה StringStorage שלנו, מממשת אינטרפייס Storage:
מניחה 2 מפתחות. ממוין תחילה לפי מפתח ראשוני, ואח"כ מיון משני לפי המפתח השני.
הספריה עצמה לא ממינת את המידע, אלא מקבלת בבנאי מפה ממוינת עם מפתח (שבנוי מ-2 מפתחות), ותוכן (שאר השורה, ללא המפתחות, או עם המפתחות, אפשר עדיין להחליט).
אומרת אם שורה קיימת בעלת ID0,ID1, יכולה גם להחזיר את אותה השורה, ויכולה להחזיר את כל השורות בעלות מפתח ראשוני ID0 (כלומר ל-ID ראשוני יתכנו מספר רשומות עם ID משניים שונים)
